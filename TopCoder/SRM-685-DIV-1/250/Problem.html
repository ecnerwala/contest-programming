<html><body bgcolor="#000000" text="#ffffff"><table><tr><td colspan="2"><h3>Problem Statement</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td>Fox Ciel is creating a new binary operation.<br></br>
<br></br>
The operation will be denoted $ and it will be defined on the finite set S = {0, 1, 2, ..., n-1}.
I.e., for each ordered pair (i, j) of elements of S the operation (i $ j) will return some element of S.<br></br>
<br></br>
For example, we can have S = {0, 1}, and we can define that (0 $ 0) = 0, (0 $ 1) = 1, (1 $ 0) = 0, and (1 $ 1) = 0.<br></br>
<br></br>
Note that Ciel's operation is not necessarily symmetric.
In other words, it is possible that for some i and j the operations (i $ j) and (j $ i) return two different values.<br></br>
<br></br>
A nice concise description of the operation $ is its "multiplication table": a square table where in row i and column j we have the value (i $ j).
You are given this "multiplication table" encoded as a vector &lt;int&gt; <b>table</b> with n^2 elements.
For each valid i and j the operation (i $ j) returns the value <b>table</b>[i*n+j].<br></br>
<br></br>
A subset T of S is called <i>good</i> if it has the following property:
for any two elements i and j in T, (i $ j) is also in T.<br></br>
<br></br>
Find and return the minimal size of a good subset of S.
Note that the answer is always defined, as there always are some good subsets.
For example, the entire set S is always good.</td></tr><tr><td colspan="2"><h3>Definition</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Class:</td><td>MultiplicationTable2</td></tr><tr><td>Method:</td><td>minimalGoodSet</td></tr><tr><td>Parameters:</td><td>vector &lt;int&gt;</td></tr><tr><td>Returns:</td><td>int</td></tr><tr><td>Method signature:</td><td>int minimalGoodSet(vector &lt;int&gt; table)</td></tr><tr><td colspan="2">(be sure your method is public)</td></tr></table></td></tr><tr><td colspan="2"><h3>Limits</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Time limit (s):</td><td>2.000</td></tr><tr><td>Memory limit (MB):</td><td>256</td></tr><tr><td>Stack limit (MB):</td><td>256</td></tr></table></td></tr><tr><td colspan="2"><h3>Constraints</h3></td></tr><tr><td align="center" valign="top">-</td><td>n will be between 1 and 50, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>table</b> will contain exactly n*n elements.</td></tr><tr><td align="center" valign="top">-</td><td>Each element in <b>table</b> will be between 0 and n-1, inclusive.</td></tr><tr><td colspan="2"><h3>Examples</h3></td></tr><tr><td align="center" nowrap="true">0)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{1,1,2,3,
 1,0,3,2,
 2,0,1,3,
 1,2,3,0}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 2</pre></td></tr><tr><td><table><tr><td colspan="2">The smallest Good set is {0,1}, we can verify:
<ul>
<li>0 $ 0 = 1</li>
<li>0 $ 1 = 1</li>
<li>1 $ 0 = 1</li>
<li>1 $ 1 = 0</li>
</ul>
</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">1)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{0,1,2,3,
 1,2,3,0,
 2,3,0,1,
 3,0,1,2}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 1</pre></td></tr><tr><td><table><tr><td colspan="2">This time the answer is 1 since {0} is a Good set.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">2)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{1,1,1,1,
 2,2,2,2,
 3,3,3,3,
 0,0,0,0}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 4</pre></td></tr><tr><td><table><tr><td colspan="2">Now the only Good set is {0,1,2,3}.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">3)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{0}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 1</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr></table><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc.  Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited.  (c)2003, TopCoder, Inc.  All rights reserved.  </p></body></html>